<?php
/**
 * @file
 * Install, update, and uninstall functions for the metatag module.
 */

/**
 * Implements hook_requirements().
 */
function metatag_requirements($phase) {
  $requirements = array();
  // Ensure translations don't break during installation.
  $t = get_t();

  if ($phase == 'install') {
    // Handle scenarios where the site had the legacy "metatags" module
    // installed but then had Metatag installed on top of it.
    if (function_exists('db_table_exists') && function_exists('db_field_exists') && function_exists('db_query') && Database::isActiveConnection()) {
      // Check if the primary table already exists.
      if (db_table_exists('metatag')) {
        // Check to see if all of the fields exist in the table. If one of the
        // fields does not exist, proceed with the fix.
        $fields = array(
          'entity_type',
          'entity_id',
          'revision_id',
          'language',
          'data',
        );
        foreach ($fields as $field) {
          // This field doesn't exist, so determine what to do.
          if (!db_field_exists('metatag', $field)) {
            // The table contains data, so rename it.
            if (db_query("SELECT COUNT(*) FROM {metatag}")->fetchField() > 0) {
              db_query("RENAME TABLE {metatag} TO {metatag}_legacy");
              $message = 'An out-of-date version of the {metatag} table was discovered. As the table contained data it was renamed with a suffix of "_legacy". This will not prevent installation from continuing, but will need to be dealt with later. See <a href="https://www.drupal.org/node/1391554">https://www.drupal.org/node/1391554</a> for further details.';
            }
            // The table is empty, so delete it.
            else {
              db_query("DROP TABLE {metatag}");
              $message = 'An out-of-date version of the {metatag} table was discovered. As the table was empty it was simply removed so that it could be recreated in the correct format. Installation may now proceed. See <a href="https://www.drupal.org/node/1391554">https://www.drupal.org/node/1391554</a> for further details.';
            }
            $requirements['metatag'] = array(
              'severity' => REQUIREMENT_WARNING,
              'title' => 'Metatag',
              'value' => $t('Legacy data discovered.'),
              'description' => $t($message),
            );
            drupal_set_message($t($message), 'warning');
            break;
          }
        }
      }
    }
  }
  elseif ($phase == 'runtime') {
    // Complete data dump of all installed modules, used later.
    $module_data = system_rebuild_module_data();

    // Add a note if Page Title is also installed.
    if (module_exists('page_title')) {
      $requirements['metatag_page_title'] = array(
        'severity' => REQUIREMENT_WARNING,
        'title' => 'Metatag',
        'value' => $t('Page Title module should be removed'),
        'description' => $t('The Metatag module is able to customize page titles, so running the Page Title module simultaneously can lead to complications. Please follow the instructions to <a href="@page">convert the Page Title settings</a> and uninstall the module.', array('@page' => 'https://www.drupal.org/node/2774833')),
      );
    }

    // Check that Entity_Translation is current.
    if (module_exists('entity_translation')
      && !empty($module_data['entity_translation'])
      && !empty($module_data['entity_translation']->schema_version)
      && $module_data['entity_translation']->schema_version < 7004) {
      $requirements['metatag_et_version'] = array(
        'severity' => REQUIREMENT_ERROR,
        'title' => 'Metatag',
        'value' => $t('<a href="@url">Entity_Translation</a> is out of date and requires updating', array('@url' => 'https://www.drupal.org/project/entity_translation')),
        'description' => $t('The Entity_Translation module is out of date and needs to be updated in order to be compatible with Metatag.'),
      );
    }

    // It's recommended to install the Imagecache Token module to make image
    // tokens easier to do.
    if (!module_exists('imagecache_token')) {
      $requirements['metatag_imagecache_token'] = array(
        'severity' => REQUIREMENT_INFO,
        'title' => 'Metatag',
        'value' => $t('The Imagecache Token module is recommended.'),
        'description' => $t("It is recommended to install the <a href=\"@url\">Imagecache Token module</a> to make it easier to control image meta tags, e.g. og:image. See the Metatag module's README.txt for details.", array('@url' => 'https://drupal.org/project/imagecache_token')),
      );
    }

    // The Admin Language module can cause problems.
    if (module_exists('admin_language') && variable_get('admin_language_force_neutral', 0)) {
      $requirements['metatag_admin_language'] = array(
        'severity' => REQUIREMENT_WARNING,
        'title' => 'Metatag',
        'value' => $t('Conflict with Admin Language module.'),
        'description' => $t("Using the \"@option\" with Metatag can lead to data loss, so it is recommended to <a href=\"@url\">disable that option</a>.", array('@option' => t('Force language neutral aliases'), '@url' => url('admin/config/regional/language/admin_language'))),
      );
    }
  }

  return $requirements;
}

/**
 * Implements hook_schema().
 */
function metatag_schema() {
  $schema['metatag'] = array(
    'fields' => array(
      'entity_type' => array(
        'type' => 'varchar',
        'length' => 32,
        'not null' => TRUE,
        'default' => '',
        'description' => 'The entity type this data is attached to.',
      ),
      'entity_id' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
        'description' => 'The entity id this data is attached to.',
      ),
      'revision_id' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
        'description' => 'The revision_id for the entity object this data is attached to.',
      ),
      'language' => array(
        'type' => 'varchar',
        'length' => 32,
        'not null' => TRUE,
        'default' => '',
        'description' => 'The language of the tag.',
      ),
      'data' => array(
        'type' => 'blob',
        'size' => 'big',
        'not null' => TRUE,
        'serialize' => TRUE,
      ),
    ),
    'indexes' => array(
      'type_revision' => array(
        'entity_type',
        'revision_id',
      ),
    ),
    'primary key' => array(
      'entity_type',
      'entity_id',
      'revision_id',
      'language',
    ),
  );

  $schema['cache_metatag'] = drupal_get_schema_unprocessed('system', 'cache');
  $schema['cache_metatag']['description'] = 'Cache table for the generated meta tag output.';

  return $schema;
}

/**
 * Implements hook_install().
 */
function metatag_install() {
  $config = config('metatag.settings');
  // Always enable the node, taxonomy term and user entities.
  foreach (array('node', 'taxonomy_term', 'user') as $entity_type) {
    // Enable the main entity type.
    $variable_name = 'metatag_enable_' . $entity_type;
    $config->set($variable_name, TRUE);

    // Update each entity bundle too.
    $entity_info = entity_get_info($entity_type);
    if (!empty($entity_info['bundles'])) {
      foreach ($entity_info['bundles'] as $bundle_name => $bundle_info) {
        $variable_name = 'metatag_enable_' . $entity_type . '__' . $bundle_name;
        variable_set($variable_name, TRUE);
      }
    }
  }

  // Possibly enable other entities, if they're specifically requested.
  foreach (entity_get_info() as $entity_type => $entity_info) {
    // Skip the three entity types that were already enabled.
    if (in_array($entity_type, array('node', 'taxonomy_term', 'user'))) {
      continue;
    }

    $variable_name = 'metatag_enable_' . $entity_type;

    // Configuration entities are skipped.
    if (isset($entity_info['configuration']) && $entity_info['configuration'] == TRUE) {
      continue;
    }

    // Entities must have bundles.
    if (empty($entity_info['bundles'])) {
      continue;
    }

    // Entities must be fieldable.
    elseif (empty($entity_info['fieldable'])) {
      continue;
    }

    // Ignore some view modes that are automatically added by certain modules.
    unset($entity_info['view modes']['ical']);
    unset($entity_info['view modes']['diff_standard']);
    unset($entity_info['view modes']['token']);

    // Entities without view modes are skipped.
    if (empty($entity_info['view modes'])) {
      continue;
    }

    // At this point, disable the entity by default.
    $entity_enabled = FALSE;

    // Anything that was specifically enabled via hook_entity_info() from older
    // versions will be enabled if not configured already.
    if (!empty($entity_info['metatag']) || !empty($entity_info['metatags'])) {
      $entity_enabled = variable_get($variable_name, 'monkey');
      if ($entity_enabled === 'monkey') {
        $entity_enabled = TRUE;
      }
    }

    variable_set($variable_name, $entity_enabled);

    // Loop through the bundles, but only if the entity is enabled.
    if ($entity_enabled) {
      foreach ($entity_info['bundles'] as $bundle_name => $bundle_info) {
        $variable_name = 'metatag_enable_' . $entity_type . '__' . $bundle_name;

        // If it wasn't specifically disabled before, enable it.
        $bundle_enabled = variable_get($variable_name, 'monkey');
        if ($bundle_name != FALSE) {
          variable_set($variable_name, TRUE);
        }
      }
    }
  }

  drupal_set_message(t('Please visit the <a href="@url">Metatag settings page</a> to determine which types of content should allow meta tags.', array('@url' => url('admin/config/search/metatags/settings'))));
}

/**
 * Implements hook_uninstall().
 */
function metatag_uninstall() {
  // This variable is created via hook_enable.
  variable_del('metatag_schema_installed');

  // Used to control whether 403/404 pages are cached.
  variable_del('metatag_cache_error_pages');

  // Used to make meta tags display on admin pages.
  variable_del('metatag_tag_admin_pages');

  // Temp variables, just in case they weren't removed already.
  variable_del('metatag_skip_update_7017');

  // Used to note that the schema for the main {metatag} table were sufficiently
  // updated.
  variable_del('metatag_has_revision_id');

  // Used to force an entity's default language values to be used if nothing
  // else matched.
  variable_del('metatag_entity_no_lang_default');

  // Optionally disable the default configurations.
  variable_del('metatag_load_defaults');

  // Optionally disables the output cache.
  variable_del('metatag_cache_output');

  // Customizable pager string.
  variable_del('metatag_pager_string');

  // Optionally enable translations of final output.
  variable_del('metatag_i18n_translate_output');

  // Optionally enable the automatic watchdog logging of i18n strings.
  variable_del('metatag_i18n_enable_watchdog');

  // Optionally disable the i18n integration.
  variable_del('metatag_i18n_disabled');

  // Optionally output core's meta tags.
  variable_del('metatag_leave_core_tags');

  // Optionally enable individual permissions for each meta tag.
  variable_del('metatag_extended_permissions');

  // Optionally load meta tags on admin pages.
  variable_del('metatag_load_all_pages');

  // Sanitize token replacement output.
  variable_del('metatag_token_sanitize');

  // Remove all possible 'enable' variables.
  foreach (entity_get_info() as $entity_type => $entity_info) {
    variable_del('metatag_enable_' . $entity_type);
    if (!empty($entity_info['bundles'])) {
      foreach ($entity_info['bundles'] as $bundle_name => $bundle_info) {
        variable_del('metatag_enable_' . $entity_type . '__' . $bundle_name);
      }
    }
  }
}

/**
 * Implements hook_enable().
 */
function metatag_enable() {
  variable_set('metatag_schema_installed', TRUE);
}

/**
 * Replace one meta tag with another in the entity records.
 *
 * @param array $sandbox
 *   A Batch API sandbox, passed by reference.
 * @param string $old_tag
 *   The meta tag that is to be replaced.
 * @param string $new_tag
 *   The meta tag that replaces the old one.
 */
function metatag_update_replace_meta_tag(&$sandbox, $old_tag, $new_tag) {
  if (!isset($sandbox['progress'])) {
    // Count of all {metatag} records that contained an entry for the old meta
    // tag.
    $records_count = db_select('metatag', 'm')
      ->condition('m.data', '%' . db_like('"" . $old_tag . ""') . '%', 'LIKE')
      ->countQuery()
      ->execute()
      ->fetchField();

    if (empty($records_count)) {
      return t('No Metatag entity records needed to have the "@tag" meta tag renamed.', array('@tag' => $old_tag));
    }

    $sandbox['max'] = $records_count;
    $sandbox['progress'] = 0;
  }

  // Count of rows that will be processed per iteration.
  $limit = 100;

  // Fetches a part of records.
  $records = db_select('metatag', 'm')
    ->fields('m', array())
    ->condition('m.data', '%' . db_like('"' . $old_tag . '"') . '%', 'LIKE')
    ->range(0, $limit)
    ->execute();

  $count = 0;
  $keys = array('entity_type', 'entity_id', 'revision_id', 'language');

  // Loop over the values and correct them.
  foreach ($records as $record) {
    $record->data = unserialize($record->data);

    if (isset($record->data[$old_tag])) {
      $record->data[$new_tag] = $record->data[$old_tag];
      unset($record->data[$old_tag]);
      drupal_write_record('metatag', $record, $keys);

      // Clear the cache for the entity this belongs to.
      entity_get_controller($record->entity_type)->resetCache(array($record->entity_id));
    }

    $count++;
  }

  if (!empty($count)) {
    $sandbox['progress'] += $count;
    $sandbox['#finished'] = min(0.99, $sandbox['progress'] / $sandbox['max']);
  }
  else {
    $sandbox['#finished'] = 1;
    return t('Converted the "@old_tag" meta tag for @count entity records to "@new_tag" meta tag.', array('@old_tag' => $old_tag, '@new_tag' => $new_tag, '@count' => $sandbox['progress']));
  }
}

/**
 * Replace one meta tag with another in the configs.
 *
 * @param string $old_tag
 *   The meta tag that is to be replaced.
 * @param string $new_tag
 *   The meta tag that replaces the old one.
 */
function metatag_update_replace_config($old_tag, $new_tag) {
  // Find all {metatag_config} records that contained an entry for the old meta
  // tag.
  $records = db_select('metatag_config', 'm')
    ->fields('m', array('cid', 'config'))
    ->condition('m.config', '%' . db_like('"' . $old_tag . '"') . '%', 'LIKE')
    ->execute();
  // This message will be returned if nothing needed to be updated.
  $none_message = t('No Metatag configuration records needed to have the "@tag" meta tag fixed. That said, there may be other configurations elsewhere that do need updating.', array('@tag' => $old_tag));

  // Loop over the values and correct them.
  if ($records->rowCount() == 0) {
    drupal_set_message($none_message);
  }
  else {
    $keys = array('cid');

    // Loop over the values and correct them.
    $counter = 0;
    foreach ($records as $record) {
      $record->config = unserialize($record->config);
      if (isset($record->config[$old_tag])) {
        $record->config[$new_tag] = $record->config[$old_tag];
        unset($record->config[$old_tag]);
        drupal_write_record('metatag_config', $record, $keys);
        $counter++;
      }
    }
    if ($counter == 0) {
      drupal_set_message($none_message);
    }
    else {
      drupal_set_message(t('Converted the "@old_tag" meta tag for @count configurations to the new "@new_tag" meta tag.', array('@old_tag' => $old_tag, '@new_tag' => $new_tag, '@count' => $counter)));
    }
  }

  // Clear all Metatag caches.
  cache_clear_all('*', 'cache_metatag', TRUE);
  drupal_static_reset('metatag_config_load_with_defaults');
  drupal_static_reset('metatag_entity_supports_metatags');
  drupal_static_reset('metatag_config_instance_info');
  drupal_static_reset('metatag_get_info');
  ctools_include('export');
  ctools_export_load_object_reset('metatag_config');
}

/**
 * Remove a specific meta tag from all configs.
 *
 * @param string $$tag_name
 *   The meta tag that is to be removed.
 */
function metatag_update_delete_config($tag_name) {
  // Find all {metatag_config} records that contained an entry for the meta tag.
  $records = db_select('metatag_config', 'm')
    ->fields('m', array('cid', 'config'))
    ->condition('m.config', '%' . db_like('"' . $tag_name . '"') . '%', 'LIKE')
    ->execute();
  // This message will be returned if nothing needed to be updated.
  $none_message = t('No Metatag configuration records needed to have the "@tag" meta tag removed.', array('@tag' => $tag_name));

  // Loop over the values and correct them.
  if ($records->rowCount() == 0) {
    drupal_set_message($none_message);
  }
  else {
    // Loop over the values and correct them.
    $counter = 0;
    foreach ($records as $record) {
      $record->config = unserialize($record->config);
      if (isset($record->config[$tag_name])) {
        unset($record->config[$tag_name]);
        drupal_write_record('metatag_config', $record, array('cid'));
        $counter++;
      }
    }
    if ($counter == 0) {
      drupal_set_message($none_message);
    }
    else {
      drupal_set_message(t('Removed the "@tag" meta tag for @count configurations.', array('@tag' => $tag_name, '@count' => $counter)));
    }
  }

  // Clear all Metatag caches.
  cache_clear_all('*', 'cache_metatag', TRUE);
  drupal_static_reset('metatag_config_load_with_defaults');
  drupal_static_reset('metatag_entity_supports_metatags');
  drupal_static_reset('metatag_config_instance_info');
  drupal_static_reset('metatag_get_info');
  ctools_include('export');
  ctools_export_load_object_reset('metatag_config');
}

/**
 * Remove duplicate records for a given entity.
 *
 * It should be OK to run this without doing a separate batch process as there
 * shouldn't be many records that have this problem. Hopefully.
 *
 * @param $entity_type
 *   The name of an entity type to check for.
 */
function metatag_update_remove_dupes($entity_type) {
  $purge_count = 0;

  // First step: fix the records. There should not be multiple records for the
  // same entity_id with different languages.
  $dupe_records = db_query("SELECT m.entity_id, count(m.language) AS the_count
    FROM {metatag} m
    WHERE
      m.entity_type = :type
    GROUP BY m.entity_id
    HAVING count(m.language) > 1", array(':type' => $entity_type));

  if (!empty($dupe_records)) {
    foreach ($dupe_records as $record) {
      $entity_id = $record->entity_id;
      $langs = db_query("SELECT m.entity_id, m.language, m.data FROM {metatag} m WHERE m.entity_type = :type AND m.entity_id = :id", array(':type' => $entity_type, ':id' => $entity_id))->fetchAll();

      // Work out which language record to remove. Will need to store this as
      // an array incase there are multiple records to purge.
      $langs_to_remove = array();

      // Check for duplicate records.
      // Outer loop starts from the beginning.
      for ($outer = 0; $outer < count($langs); $outer++) {
        // This record may have been removed already.
        if (isset($langs[$outer])) {
          // Inner loop starts from the end.
          for ($inner = count($langs) - 1; $inner > 0; $inner--) {
            // Work out if the outer loop's data is the same as the inner
            // loop's.
            if (isset($langs[$inner]) && $langs[$outer]->data == $langs[$inner]->data) {
              // Remove the second record.
              $langs_to_remove[] = $langs[$inner]->langcode;
              unset($langs[$inner]);
            }
          }
        }
      }

      // Only one record left.
      if (count($langs) == 1) {
        // This is how it should be, this record is fine.
      }
      // More than one record, work out which one to keep.
      elseif (count($langs) > 1) {
        // Work out the entity's language.
        $entity = entity_load($entity_type, $entity_id);
        $entity_language = $entity->langcode;
        if (empty($language)) {
          $entity_language = LANGUAGE_NONE;
        }

        // Work out if the entity's language record exists.
        $lang_pos = NULL;
        foreach ($langs as $key => $record) {
          if ($record->langcode == $entity_language) {
            $lang_pos = $key;
            break;
          }
        }
        // If the language record exists, delete the others.
        if (isset($lang_pos)) {
          foreach ($langs as $key => $record) {
            if ($record->langcode != $entity_language) {
              $langs_to_remove[] = $record->langcode;
            }
          }
        }
        // Otherwise look for a record for the site's default language.
        else {
          foreach ($langs as $key => $record) {
            if ($record->langcode == $GLOBALS['language']->langcode) {
              $lang_pos = $key;
              break;
            }
          }
          if (isset($lang_pos)) {
            foreach ($langs as $key => $record) {
              if ($record->langcode != $GLOBALS['language']->langcode) {
                $langs_to_remove[] = $record->langcode;
              }
            }
          }
          // Finally check for LANGUAGE_NONE.
          else {
            foreach ($langs as $key => $record) {
              if ($record->langcode == LANGUAGE_NONE) {
                $lang_pos = $key;
                break;
              }
            }
            if (isset($lang_pos)) {
              foreach ($langs as $key => $record) {
                if ($record->langcode != LANGUAGE_NONE) {
                  $langs_to_remove[] = $record->langcode;
                }
              }
            }
          }
        }
      }

      // Purge the redundant records.
      if (!empty($langs_to_remove)) {
        $purge_count += db_delete('metatag')
          ->condition('entity_type', $entity_type)
          ->condition('entity_id', $entity_id)
          ->condition('language', $langs_to_remove)
          ->execute();
      }
    }
  }

  if (empty($purge_count)) {
    drupal_set_message(t('No duplicate :entity_type records were found (this is a good thing).', array(':entity_type' => $entity_type)));
    watchdog('metatag', 'No duplicate :entity_type records were found (this is a good thing).', array(':entity_type' => $entity_type));
  }
  else {
    drupal_set_message(t('Purged :count duplicate :entity_type record(s).', array(':count' => $purge_count, ':entity_type' => $entity_type)));
    watchdog('metatag', 'Purged :count duplicate :entity_type record(s).', array(':count' => $purge_count, ':entity_type' => $entity_type));
    return;
  }
}

/**
 *  Implments hook_update_last_removed().
 */
function metatag_update_last_removed() {
  return '7112';
}

/**
 * The Publisher meta tag is now part of the Google Plus submodule.
 */
function metatag_update_1000() {
  cache_clear_all('*', 'cache_metatag', TRUE);
  // Remove variables not needed for Backdrop.
  varaible_del('metatag_page_region');
  // Switch from variables to config.
    // @todo.

}
